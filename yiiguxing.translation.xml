<application>
  <component name="AppStorage">
    <histories>
      <item value="Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them!" />
      <item value="regular Post Processors" />
      <item value="for picking up proxies etc" />
      <item value="This will typically be used by application contexts to register * dependencies that are resolved in other ways" />
      <item value="typically" />
      <item value="eager-initializing" />
      <item value="any ordering semantics expressed through implementing the * {@code PriorityOrdered} or {@code Ordered} interface will be ignored for * programmatically registered post-processors. Furthermore, the * {@link org.springframework.core.annotation.Order @Order} annotation is not * taken into account for {@code BeanFactoryPostProcessor} beans" />
      <item value="violating" />
      <item value="premature" />
      <item value="Useful for custom config files targeted at system administrators that * override bean properties configured in the application context. See * {@link PropertyResourceConfigurer} and its concrete implementations for * out-of-the-box solutions that address such configuration needs" />
      <item value="underlying" />
      <item value="adapting" />
      <item value="detecting" />
      <item value="Application Listener Detector" />
      <item value="not eligible for auto-proxying" />
      <item value="eligible" />
      <item value="Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors" />
      <item value="a bean is not eligible for getting processed by all BeanPostProcessors" />
      <item value="Delegate" />
      <item value="Aware" />
      <item value="Nested Dependency Descriptor" />
      <item value="resolve Shortcut" />
      <item value="transient" />
      <item value="Find out about ambiguity: In case of the same type difference weight" />
      <item value="is Factory Method Unique" />
      <item value="raw Arguments" />
      <item value="opportunity" />
      <item value="set callbacks directly on the instance instead of in the // enhanced class (via the Enhancer) in order to avoid memory leaks" />
      <item value="avoid" />
      <item value="memory leaks" />
      <item value="ambiguous Constructors" />
      <item value="do not look any further, there are only less greedy constructors left" />
      <item value="Already found greedy constructor that can be satisfied" />
      <item value="ambiguity" />
      <item value="Choose this factory method if it represents the closest match." />
      <item value="ambiguous Factory Methods" />
      <item value="is Lenient Constructor Resolution" />
      <item value="raw" />
      <item value="determine" />
      <item value="Implicitly Appeared Singleton Exception" />
      <item value="obtain" />
      <item value="autowire Constructor" />
      <item value="Determine whether the given bean instance requires destruction by this * post-processor. * &lt;p&gt;The default implementation returns {@code true}. If a pre-5 implementation * of {@code DestructionAwareBeanPostProcessor} does not provide a concrete * implementation of this method, Spring silently assumes {@code true} as well" />
      <item value="autodetect" />
      <item value="Typically, post-processors that populate beans via marker interfaces * or the like will implement {@link #postProcessBeforeInitialization}, * while post-processors that wrap beans with proxies will normally * implement {@link #postProcessAfterInitialization}." />
      <item value="derive" />
      <item value="predicting the eventual type of a processed bean" />
      <item value="for example introspect * the bean definition in order to prepare some cached metadata before post-processing * actual instances of a bean. It is also allowed to modify the bean definition but * &lt;i&gt;only&lt;/i&gt; for definition properties which are actually intended for concurrent * modification. Essentially, this only applies to operations defined on the * {@link RootBeanDefinition} itself but not to the properties of its base classes." />
      <item value="Post-process the given property values before the factory applies them * to the given bean, without any need for property descriptors. * &lt;p&gt;Implementations should return {@code null} (the default) if they provide a custom * {@link #postProcessPropertyValues} implementation, and {@code pvs} otherwise. * In a future version of this interface (with {@link #postProcessPropertyValues} removed), * the default implementation will return the given {@code pvs} as-is directly." />
      <item value="Perform operations after the bean has been instantiated, via a constructor or factory method, * but before Spring property population (from explicit properties or autowiring) occurs. * &lt;p&gt;This is the ideal callback for performing custom field injection on the given bean * instance, right before Spring's autowiring kicks in" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="798" />
        <entry key="ENGLISH" value="799" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="4" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="4" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
  </component>
</application>