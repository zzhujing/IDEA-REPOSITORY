<application>
  <component name="AppStorage">
    <histories>
      <item value="stract base class for {@link EventLoopGroup} implementations that handles their tasks with multiple threads at * the same time" />
      <item value="stract" />
      <item value="Create a new EventExecutor which will later then accessible via the {@link #next()} method. This method will be * called for each thread that will serve this {@link MultithreadEventExecutorGroup}" />
      <item value="via" />
      <item value="accessible" />
      <item value="subtype" />
      <item value="To take advantage of this thread-local variable" />
      <item value="it yields slight performance advantage over using a hash * table, and it is useful when accessed frequently" />
      <item value="subtle" />
      <item value="A special variant of {@link ThreadLocal} that yields higher access performance when accessed from a" />
      <item value="yields" />
      <item value="variant" />
      <item value="notify" />
      <item value="which is" />
      <item value="Submits a value-returning task for execution and returns a * Future representing the pending results of the task. The * Future's {@code get} method will return the task's result upon * successful completion" />
      <item value="Executes the given tasks, returning a list of Futures holding * their status and results when all complete. * {@link Future#isDone} is {@code true} for each * element of the returned list. * Note that a &lt;em&gt;completed&lt;/em&gt; task could have * terminated either normally or by throwing an exception. * The results of this method are undefined if the given * collection is modified while this operation is in progress" />
      <item value="the period between successive executions" />
      <item value="the delay between the termination of one * execution and the commencement of the next" />
      <item value="Creates and executes a periodic action that becomes enabled first * after the given initial delay, and subsequently with the given * period; that is executions will commence after * {@code initialDelay} then {@code initialDelay+period}, then * {@code initialDelay + 2 * period}, and so on. * If any execution of the task * encounters an exception, subsequent executions are suppressed. * Otherwise, the task will only terminate via cancellation or * termination of the executor. If any execution of this task * takes longer than its period, then subsequent executions * may start late, but will not concurrently execute" />
      <item value="subsequent" />
      <item value="suppressed" />
      <item value="commence" />
      <item value="period" />
      <item value="subsequently" />
      <item value="periodic" />
      <item value="periodically" />
      <item value="if any do" />
      <item value="Upon" />
      <item value="normal" />
      <item value="Upon normal or exceptional return" />
      <item value="The results of this method are undefined if the given * collection is modified while this operation is in progress" />
      <item value="progress" />
      <item value="either normally" />
      <item value="other common closure-like" />
      <item value="pending" />
      <item value="representing" />
      <item value="There are no guarantees beyond best-effort attempts to stop * processing actively executing tasks. For example, typical * implementations will cancel via {@link Thread#interrupt}, so any * task that fails to respond to interrupts may never terminate" />
      <item value="halts the * processing of waiting tasks" />
      <item value="awaiting" />
      <item value="nitiates an orderly shutdown in which previously submitted * tasks are executed, but no new tasks will be accepted. * Invocation has no additional effect if already shut down. * * &lt;p&gt;This method does not wait for previously submitted tasks to * complete execution. Use {@link #awaitTermination awaitTermination} * to do that" />
      <item value="This method does not wait for previously submitted tasks to * complete execution. Use {@link #awaitTermination awaitTermination} * to do that" />
      <item value="actively" />
      <item value="prevents" />
      <item value="attempts" />
      <item value="previously" />
      <item value="while the {@link #shutdownNow} method prevents waiting * tasks from starting and attempts to stop currently executing tasks" />
      <item value="An {@link Executor} that provides methods to manage termination and * methods that can produce a {@link Future} for tracking progress of * one or more asynchronous tasks" />
      <item value="specified" />
      <item value="not necessarily created by Netty" />
      <item value="arbitrary" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="830" />
        <entry key="ENGLISH" value="831" />
        <entry key="DANISH" value="3" />
        <entry key="FRENCH" value="6" />
        <entry key="CATALAN" value="2" />
        <entry key="KANNADA" value="1" />
        <entry key="LATVIAN" value="3" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
</application>