<application>
  <component name="AppStorage">
    <histories>
      <item value="Find an {@code @ExceptionHandler} method for the given exception. The default implementation searches methods in the class hierarchy of the controller first" />
      <item value="Find an @ExceptionHandler method for the given exception. The default implementation searches methods in the class hierarchy of the controller first and if not found, it continues searching for additional @ExceptionHandler methods assuming some @ControllerAdvice Spring-managed beans were detected" />
      <item value="Find an {@code @ExceptionHandler} method for the given exception. The default * implementation searches methods in the class hierarchy of the controller first * and if not found, it continues searching for additional {@code @ExceptionHandler} * methods assuming some {@linkplain ControllerAdvice @ControllerAdvice}" />
      <item value="@param exception the raised exception * @return a method to handle the exception, or {@code null} if none" />
      <item value="none" />
      <item value="managed beans were detected. * @param handlerMethod the method where the exception was raised (may be {@code null}) * @param exception the raised exception * @return a method to handle the exception, or" />
      <item value="determine" />
      <item value="detect" />
      <item value="检测" />
      <item value="detect Exception Mappings" />
      <item value="Resolved Type" />
      <item value="Media Type" />
      <item value="specification" />
      <item value="Content Negotiation Strategy" />
      <item value="concrete" />
      <item value="AUDIT" />
      <item value="redirect Model" />
      <item value="redirect Model Scenario" />
      <item value="URI TEMPLATE VARIABLES ATTRIBUTE" />
      <item value="Consider fallback matches if the first pass failed to find anything" />
      <item value="but in the case of a dependency collection, not the very same bean itself" />
      <item value="Map from dependency type to corresponding autowired value" />
      <item value="corresponding" />
      <item value="is Numeric" />
      <item value="Determines if the specified character is a digit" />
      <item value="is Beside" />
      <item value="Temporal" />
      <item value="@RequestParam-annotated method arguments. This excludes Map params where the annotation does not specify a name. See RequestParamMapMethodArgumentResolver instead for such params" />
      <item value="Return a variant of this {@code MethodParameter} which points to the * same parameter but one nesting level deeper" />
      <item value="EMPTY ARGS" />
      <item value="underlying" />
      <item value="Invocable" />
      <item value="Invocable Handler Method" />
      <item value="redirect" />
      <item value="Ωredirect" />
      <item value="restrict Default Supported Methods" />
      <item value="Given a pattern and a full path, determine the pattern-mapped part. This method is supposed to find out which part of the path is matched dynamically through an actual pattern, that is, it strips off a statically defined leading path from the given full path, returning only the actually pattern-matched part of the path. For example: For &quot;myroot/*.html&quot; as pattern and &quot;myroot/myfile.html&quot; as full path, this method should return &quot;myfile.html&quot;. The detailed determination rules are specified to this PathMatcher's matching strategy. A simple implementation may return the given full path as-is in case of an actual pattern, and the empty String in case of the pattern not containing any dynamic parts (i.e. the pattern parameter being a static path that wouldn't qualify as an actual pattern). A sophisticated implementation will differentiate between the static parts and the dynamic parts of the given path pattern." />
      <item value="extract Path Within Pattern" />
      <item value="uri Template Variables" />
      <item value="use Trailing Slash Match" />
      <item value="Typically" />
      <item value="Bean name prefix for target beans behind scoped proxies. Used to exclude those targets from handler method detection, in favor of the corresponding proxies. We're not checking the autowire-candidate status here, which is how the proxy target filtering problem is being handled at the autowiring level, since autowire-candidate may have been turned to false for other reasons, while still expecting the bean to be eligible for handler methods. Originally defined in org.springframework.aop.scope.ScopedProxyUtils but duplicated here to avoid a hard dependency on the spring-aop module." />
      <item value="synthetic" />
      <item value="sanitized Path Within App" />
      <item value="Path Exposing Handler Interceptor" />
      <item value="raw" />
      <item value="get Path Within Application" />
      <item value="matching Beans" />
      <item value="indicate" />
      <item value="indicates Multiple Beans" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1023" />
        <entry key="ENGLISH" value="1024" />
        <entry key="DANISH" value="5" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="7" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="6" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>