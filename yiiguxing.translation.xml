<application>
  <component name="AppStorage">
    <histories>
      <item value="Nested Dependency Descriptor" />
      <item value="resolve Shortcut" />
      <item value="transient" />
      <item value="Find out about ambiguity: In case of the same type difference weight" />
      <item value="is Factory Method Unique" />
      <item value="raw Arguments" />
      <item value="opportunity" />
      <item value="set callbacks directly on the instance instead of in the // enhanced class (via the Enhancer) in order to avoid memory leaks" />
      <item value="avoid" />
      <item value="memory leaks" />
      <item value="ambiguous Constructors" />
      <item value="do not look any further, there are only less greedy constructors left" />
      <item value="Already found greedy constructor that can be satisfied" />
      <item value="ambiguity" />
      <item value="Choose this factory method if it represents the closest match." />
      <item value="ambiguous Factory Methods" />
      <item value="is Lenient Constructor Resolution" />
      <item value="raw" />
      <item value="determine" />
      <item value="Implicitly Appeared Singleton Exception" />
      <item value="obtain" />
      <item value="autowire Constructor" />
      <item value="Determine whether the given bean instance requires destruction by this * post-processor. * &lt;p&gt;The default implementation returns {@code true}. If a pre-5 implementation * of {@code DestructionAwareBeanPostProcessor} does not provide a concrete * implementation of this method, Spring silently assumes {@code true} as well" />
      <item value="autodetect" />
      <item value="Typically, post-processors that populate beans via marker interfaces * or the like will implement {@link #postProcessBeforeInitialization}, * while post-processors that wrap beans with proxies will normally * implement {@link #postProcessAfterInitialization}." />
      <item value="typically" />
      <item value="derive" />
      <item value="predicting the eventual type of a processed bean" />
      <item value="for example introspect * the bean definition in order to prepare some cached metadata before post-processing * actual instances of a bean. It is also allowed to modify the bean definition but * &lt;i&gt;only&lt;/i&gt; for definition properties which are actually intended for concurrent * modification. Essentially, this only applies to operations defined on the * {@link RootBeanDefinition} itself but not to the properties of its base classes." />
      <item value="Post-process the given property values before the factory applies them * to the given bean, without any need for property descriptors. * &lt;p&gt;Implementations should return {@code null} (the default) if they provide a custom * {@link #postProcessPropertyValues} implementation, and {@code pvs} otherwise. * In a future version of this interface (with {@link #postProcessPropertyValues} removed), * the default implementation will return the given {@code pvs} as-is directly." />
      <item value="Perform operations after the bean has been instantiated, via a constructor or factory method, * but before Spring property population (from explicit properties or autowiring) occurs. * &lt;p&gt;This is the ideal callback for performing custom field injection on the given bean * instance, right before Spring's autowiring kicks in" />
      <item value="This callback will be applied to bean definitions with their bean class, * as well as to factory-method definitions in which case the returned bean type * will be passed in here" />
      <item value="short-circuited" />
      <item value="satisfied" />
      <item value="eager" />
      <item value="unsatisfied Non Simple Properties" />
      <item value="specified" />
      <item value="Guarantee" />
      <item value="Delegation" />
      <item value="original Bean Name" />
      <item value="canonical Name" />
      <item value="variant" />
      <item value="Purpose" />
      <item value="in case of creation errors" />
      <item value="multiple candidates found with none marked as primary" />
      <item value="Qualifier" />
      <item value="英雄联盟" />
      <item value="联盟" />
      <item value="which allows to register existing singleton instances programmatically" />
      <item value="programmatically" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="776" />
        <entry key="ENGLISH" value="777" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="4" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="4" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
  </component>
</application>