<application>
  <component name="AppStorage">
    <histories>
      <item value="Theme Source" />
      <item value="until no further ones appear" />
      <item value="Defines the contract for adding one or more ClassFileTransformers to a ClassLoader. Implementations may operate on the current context ClassLoader or expose their own instrumentable ClassLoader" />
      <item value="WEAVER" />
      <item value="LOAD TIME WEAVER BEAN NAME" />
      <item value="register Resolvable Dependency" />
      <item value="BeanFactory interface not registered as resolvable type in a plain factory" />
      <item value="Stub Property Source" />
      <item value="Set whether to extract the old property value when applying a * property editor to a new value for a property" />
      <item value="to be considered as thread-safe either" />
      <item value="Typically" />
      <item value="Encapsulates" />
      <item value="Capable" />
      <item value="representing" />
      <item value="resolve Nested Placeholders" />
      <item value="Interface for resolving properties against any underlying source" />
      <item value="Abstract base class representing a source of name/value property pairs. The underlying source object may be of any type T that encapsulates properties. Examples include java.util.Properties objects, java.util.Map objects, ServletContext and ServletConfig objects (for access to init parameters). Explore the PropertySource type hierarchy to see provided implementations. PropertySource objects are not typically used in isolation, but rather through a PropertySources object, which aggregates property sources and in conjunction with a PropertyResolver implementation that can perform precedence-based searches across the set of PropertySources. PropertySource identity is determined not based on the content of encapsulated properties, but rather based on the name of the PropertySource alone. This is useful for manipulating PropertySource objects when in collection contexts. See operations in MutablePropertySources as well as the named(String) and toString() methods for details. Note that when working with @Configuration classes that the @PropertySource annotation provides a convenient and declarative way of adding property sources to the enclosing Environment." />
      <item value="replacing them with corresponding * property values as resolved by {@link #getProperty}. Unresolvable placeholders with * no default value are ignored and passed through unchanged" />
      <item value="manually" />
      <item value="remove Manual Singleton Name" />
      <item value="PASSTHROUGH" />
      <item value="particular" />
      <item value="via the Enhancer" />
      <item value="Property Editor Registry" />
      <item value="Property Editor Registrar" />
      <item value="add Scalar Converters" />
      <item value="add Collection Converters" />
      <item value="generic" />
      <item value="Resolvable Type" />
      <item value="Generic Converter" />
      <item value="Convertible Pair" />
      <item value="is Primitive" />
      <item value="Standard Java File Manager" />
      <item value="Java Bean Introspector Demo" />
      <item value="Vetoable" />
      <item value="Votable" />
      <item value="multicast" />
      <item value="if either" />
      <item value="An annotation A is indirectly present on an element E if E has a RuntimeVisibleAnnotations or RuntimeVisibleParameterAnnotations or RuntimeVisibleTypeAnnotations attribute, and A 's type is repeatable, and the attribute contains exactly one annotation whose value element contains A and whose type is the containing annotation type of A 's type" />
      <item value="The terms directly present, indirectly present, present, and associated are used throughout this interface to describe precisely which annotations are returned by methods" />
      <item value="look through" />
      <item value="associated" />
      <item value="directly present" />
      <item value="terms" />
      <item value="affecting" />
      <item value="reflectively" />
      <item value="annotated" />
      <item value="Represents" />
      <item value="get Actually Class Name" />
      <item value="实际的" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="873" />
        <entry key="ENGLISH" value="874" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="4" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="5" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>