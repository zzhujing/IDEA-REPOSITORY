<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="474" />
    <option name="newTranslationDialogWidth" value="1510" />
    <option name="newTranslationDialogX" value="784" />
    <option name="newTranslationDialogY" value="736" />
    <histories>
      <item value="1. If read count nonzero or write count nonzero and owner is a different thread, fail. 2. If count would saturate, fail. (This can only happen if count is already nonzero.) 3. Otherwise, this thread is eligible for lock if it is either a reentrant acquire or queue policy allows it. If so, update state and set owner." />
      <item value="saturate" />
      <item value="Walkthrough" />
      <item value="always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue" />
      <item value="waitStatus must be 0 or PROPAGATE. Indicate that we need a signal, but don't park yet. Caller will need to retry to make sure it cannot acquire before parking" />
      <item value="Used by condition wait methods as well as acquire" />
      <item value="has Queued Predecessors" />
      <item value="strictly" />
      <item value="reentrant" />
      <item value="efficient" />
      <item value="&lt;p&gt;Throughput and scalability are generally highest for the default barging (also known as &lt;em&gt;greedy&lt;em&gt;, &lt;em&gt;renouncement&lt;em&gt;, and &lt;em&gt;convoy-avoidance&lt;em&gt;) strategy. While this is not guaranteed to be fair or starvation-free, earlier queued threads are allowed to recontend before later queued threads, and each recontention has an unbiased chance to succeed against incoming threads. Also, while acquires do not &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple invocations of {@code tryAcquire} interspersed with other computations before blocking. This gives most of the benefits of spins when exclusive synchronization is only briefly held, without most of the liabilities when it isn't. If so desired, you can augment this by preceding calls to acquire methods with &quot;fast-path&quot; checks, possibly prechecking {@link hasContended} andor {@link hasQueuedThreads} to only do so if the synchronizer is likely not to be contended." />
      <item value="and each recontention has an unbiased chance to succeed against incoming threads" />
      <item value="recontention" />
      <item value="While this is not guaranteed to be fair or starvation-free, earlier queued threads are allowed to recontend before later queued threads," />
      <item value="guaranteed" />
      <item value="&lt;p&gt;Throughput and scalability are generally highest for the default barging (also known as &lt;em&gt;greedy&lt;em&gt;, &lt;em&gt;renouncement&lt;em&gt;, and &lt;em&gt;convoy-avoidance&lt;em&gt;) strategy." />
      <item value="Throughput and scalability are generally highest for the default barging" />
      <item value="barging" />
      <item value="Because checks in acquire are invoked before enqueuing, a newly acquiring thread may &lt;em&gt;barge&lt;em&gt; ahead of others that are blocked and queued." />
      <item value="&lt;em&gt;barge&lt;em&gt; ahead of others" />
      <item value="barge" />
      <item value="involve cascading signals" />
      <item value="enforce" />
      <item value="assist" />
      <item value="diagnostic" />
      <item value="inspecting&#10;" />
      <item value="These can be exported as desired into classes using an {@code AbstractQueuedSynchronizer} for their synchronization mechanics." />
      <item value="exported" />
      <item value="instrumentation&#10;&#10;" />
      <item value="instrumentationt&#10;" />
      <item value="inspection&#10;" />
      <item value="so if this constraint" />
      <item value="so if this consta" />
      <item value="constraint&#10;" />
      <item value=". No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of AbstractQueuedSynchronizer.ConditionObject depends of course on the semantics of its synchronizer implementation.&#10;" />
      <item value="otherwise&#10;" />
      <item value="and acquire, given this saved state value, eventually restores this object to its previous acquired stat&#10;" />
      <item value="and acquire, given this saved state value, eventually restores this object to its previous acquired stat" />
      <item value="method release invoked with the current getState value fully releases this object&#10;" />
      <item value=", method release invoked with the current getState value fully releases this object&#10;" />
      <item value="held with respect to the current thread&#10;" />
      <item value="held with respect to the cu" />
      <item value="held with respect to&#10;" />
      <item value="held with" />
      <item value="This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively reports whether synchronization is exclusively held with respect to the current threa&#10;" />
      <item value="come into play&#10;" />
      <item value="come into&#10;" />
      <item value=" This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well&#10;&#10;" />
      <item value=" This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as we&#10;" />
      <item value="mechanical&#10;" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="4985" />
        <entry key="ENGLISH" value="4986" />
        <entry key="CHINESE_CLASSICAL" value="1" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="8" />
        <entry key="GERMAN" value="9" />
        <entry key="FRENCH" value="17" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="4" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALAY" value="1" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="SWEDISH" value="3" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1631461123710" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>