<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="3425" />
    <option name="newTranslationDialogY" value="398" />
    <histories>
      <item value="bridge" />
      <item value="birdge Method" />
      <item value="the take over userid" />
      <item value="the hand over userid" />
      <item value="FEMALE" />
      <item value="Camel Case Splitting Field Naming Strategy" />
      <item value="Camel Case Abbreviating Field Naming Strategy" />
      <item value="introduce" />
      <item value="intro" />
      <item value="on behalf of" />
      <item value="on nehalf of" />
      <item value="on nehalf " />
      <item value="on" />
      <item value="Î©" />
      <item value="apparently First Queued Is Exclusive" />
      <item value="writer Should Block" />
      <item value="has Queued Threads" />
      <item value="has Queued Predecessors" />
      <item value="Queries whether any threads have been waiting to acquire longer than the current thread." />
      <item value="waitStatus value to indicate the next acquireShared should unconditionally propagate." />
      <item value="waitStatus value to indicate thread is waiting on condition" />
      <item value="waitStatus value to indicate successor's thread needs unparking" />
      <item value="waitStatus must be 0 or PROPAGATE. Indicate that we need a signal, but don't park yet. Caller will need to retry to make sure it cannot acquire before parking" />
      <item value="SIGNAL" />
      <item value="This node has already set status asking a release to signal it, so it can safely park." />
      <item value="The null check could be elided, but is present to help the VM" />
      <item value="elided" />
      <item value="predecessor" />
      <item value="Because condition queues are accessed only when holding in exclusive mode, we just need a simple linked queue to hold nodes while they are waiting on conditions" />
      <item value="precede" />
      <item value="diagnostic" />
      <item value="&lt;p&gt;If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate." />
      <item value="Returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of a subset of elements taken from this stream that match the given predicate" />
      <item value="consisting" />
      <item value="a stream consisting of the remaining elements of this stream after dropping a subset of elements that match the given predicate" />
      <item value="Returns, if this stream is ordered, a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate" />
      <item value="corrupted class files" />
      <item value="old Symbol Ref" />
      <item value="misleadingly named" />
      <item value="assigns" />
      <item value="Before the {@code Class} can be used it must be resolved." />
      <item value="Before the {@code Class} can be used it must be resolved" />
      <item value="Associated web resources for this webapp." />
      <item value="Use --illegal-access=warn to enable warnings of further illegal reflective access operations" />
      <item value="UNCONDITIONAL" />
      <item value="TRUSTED" />
      <item value="Otherwise, the call proceeds as if this method handle were first adjusted by calling {@link asType asType} to adjust this method handle to the required type, and then the call proceeds as if by {@link invokeExact invokeExact} on the adjusted method handle." />
      <item value="if this method handle were first adjusted by calling {@link asType asType} to adjust this method handle to the required type" />
      <item value="invoke Exact" />
      <item value="Method Handle" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2610" />
        <entry key="ENGLISH" value="2611" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="DANISH" value="7" />
        <entry key="GERMAN" value="8" />
        <entry key="FRENCH" value="14" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="5" />
        <entry key="PORTUGUESE" value="6" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1611811010167" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>