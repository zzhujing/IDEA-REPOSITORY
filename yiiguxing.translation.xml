<application>
  <component name="AppStorage">
    <histories>
      <item value="raw" />
      <item value="determine" />
      <item value="Implicitly Appeared Singleton Exception" />
      <item value="obtain" />
      <item value="autowire Constructor" />
      <item value="Determine whether the given bean instance requires destruction by this * post-processor. * &lt;p&gt;The default implementation returns {@code true}. If a pre-5 implementation * of {@code DestructionAwareBeanPostProcessor} does not provide a concrete * implementation of this method, Spring silently assumes {@code true} as well" />
      <item value="autodetect" />
      <item value="Typically, post-processors that populate beans via marker interfaces * or the like will implement {@link #postProcessBeforeInitialization}, * while post-processors that wrap beans with proxies will normally * implement {@link #postProcessAfterInitialization}." />
      <item value="typically" />
      <item value="derive" />
      <item value="predicting the eventual type of a processed bean" />
      <item value="for example introspect * the bean definition in order to prepare some cached metadata before post-processing * actual instances of a bean. It is also allowed to modify the bean definition but * &lt;i&gt;only&lt;/i&gt; for definition properties which are actually intended for concurrent * modification. Essentially, this only applies to operations defined on the * {@link RootBeanDefinition} itself but not to the properties of its base classes." />
      <item value="Post-process the given property values before the factory applies them * to the given bean, without any need for property descriptors. * &lt;p&gt;Implementations should return {@code null} (the default) if they provide a custom * {@link #postProcessPropertyValues} implementation, and {@code pvs} otherwise. * In a future version of this interface (with {@link #postProcessPropertyValues} removed), * the default implementation will return the given {@code pvs} as-is directly." />
      <item value="Perform operations after the bean has been instantiated, via a constructor or factory method, * but before Spring property population (from explicit properties or autowiring) occurs. * &lt;p&gt;This is the ideal callback for performing custom field injection on the given bean * instance, right before Spring's autowiring kicks in" />
      <item value="This callback will be applied to bean definitions with their bean class, * as well as to factory-method definitions in which case the returned bean type * will be passed in here" />
      <item value="short-circuited" />
      <item value="satisfied" />
      <item value="eager" />
      <item value="unsatisfied Non Simple Properties" />
      <item value="specified" />
      <item value="Guarantee" />
      <item value="Delegation" />
      <item value="original Bean Name" />
      <item value="canonical Name" />
      <item value="variant" />
      <item value="Purpose" />
      <item value="in case of creation errors" />
      <item value="multiple candidates found with none marked as primary" />
      <item value="Qualifier" />
      <item value="英雄联盟" />
      <item value="联盟" />
      <item value="which allows to register existing singleton instances programmatically" />
      <item value="programmatically" />
      <item value="Capable" />
      <item value="Note that this interface is not implemented by * {@link org.springframework.context.ApplicationContext} facades, * as it is hardly ever used by application code. That said, it is available * from an application context too, accessible through ApplicationContext's * {@link org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()} * method." />
      <item value="Note that this interface is not implemented by * {@link org.springframework.context.ApplicationContext} facades, * as it is hardly ever used by application code. That said, it is available * from an application context too, accessible through ApplicationContext's * {@link org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()} * method" />
      <item value="facades" />
      <item value="This is particularly useful for WebWork Actions and * Tapestry Page objects, for example" />
      <item value="Integration code for other frameworks can leverage this interface to * wire and populate existing bean instances that Spring does not control * the lifecycle of" />
      <item value="leverage" />
      <item value="Integration code" />
      <item value="Integration" />
      <item value="This subinterface of BeanFactory is not meant to be used in normal * application code: stick to {@link org.springframework.beans.factory.BeanFactory} * or {@link org.springframework.beans.factory.ListableBeanFactory} for * typical use cases" />
      <item value="stick" />
      <item value="functionality" />
      <item value="capable" />
      <item value="bean factories that are capable of * autowiring" />
      <item value="beans Of Type Including Ancestors" />
      <item value="Ancestors" />
      <item value="bean" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="760" />
        <entry key="ENGLISH" value="761" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="4" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="4" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
  </component>
</application>