<application>
  <component name="AppStorage">
    <histories>
      <item value="The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue" />
      <item value="Try immediate barge, backing up to normal * acquire on failure" />
      <item value="fair" />
      <item value="Ωfair" />
      <item value="has Queued Predecessors" />
      <item value="Unlinks" />
      <item value="successor" />
      <item value="acquire" />
      <item value="This node has already set status asking a release * to signal it, so it can safely park." />
      <item value="acquire Queued" />
      <item value="add Waiter" />
      <item value="The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block" />
      <item value="The successor of this node is (or will soon be) * blocked (via park)," />
      <item value="waitStatus value to indicate successor's thread needs unparking" />
      <item value="indicate" />
      <item value="Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor." />
      <item value="park" />
      <item value="should Park After Failed Acquire" />
      <item value="EXCLUSIVE" />
      <item value="So the currently released * contender thread may need to rewait" />
      <item value="it only gives the right to contend" />
      <item value="contend" />
      <item value="guarantee" />
      <item value="The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and * Hagersten" />
      <item value="Craig, Landin, and * Hagersten" />
      <item value="Craig" />
      <item value="its waitStatus is guaranteed not to be * CANCELLED" />
      <item value="is Held Exclusively" />
      <item value="exclusive mode" />
      <item value="exclusive" />
      <item value="AbstractQueuedSynchronizer" />
      <item value="Queue" />
      <item value="semaphore" />
      <item value="The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of waiting, nor is it required to support interruption of the actual suspension of the thread. An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface. As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread. An implementation should document this behav" />
      <item value="or not requiring a lock to be held * when performing notifications" />
      <item value="guaranteed ordering for notifications" />
      <item value="guaranteed" />
      <item value="semantics" />
      <item value="behavior" />
      <item value="e; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per obj" />
      <item value="factors out" />
      <item value="forget" />
      <item value="forgot" />
      <item value="CAPTCHA" />
      <item value="CAPTHER" />
      <item value="Spinning" />
      <item value="退出" />
      <item value="back up" />
      <item value="离职" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1367" />
        <entry key="ENGLISH" value="1368" />
        <entry key="DANISH" value="7" />
        <entry key="GERMAN" value="6" />
        <entry key="FRENCH" value="8" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="7" />
        <entry key="HUNGARIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>