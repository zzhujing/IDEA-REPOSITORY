<application>
  <component name="AppStorage">
    <histories>
      <item value="compose" />
      <item value="run After Both Async" />
      <item value="Queries whether any threads have been waiting to acquire longer * than the current thread" />
      <item value="Queries whether any threads have been waiting to acquire longer than the current thread. An invocation of this method is equivalent to (but may be more efficient than): getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads() Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that some other thread will acquire before the current thread. Likewise, it is possible for another thread to win a race to enqueue after this method has returned false, due to the queue being empty. This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer's tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:" />
      <item value="a queued thread preceding the * current thread" />
      <item value="join" />
      <item value="fork" />
      <item value="Privileged Thread Factory" />
      <item value="waiting if necessary up to the specified wait * time if none are yet present." />
      <item value="sketch" />
      <item value="associated" />
      <item value="on Advance" />
      <item value="Phaser" />
      <item value="Cyclic Barrier" />
      <item value="HASH BITS" />
      <item value="0 x 7 fffffff" />
      <item value="Strategy interface used by TransactionInterceptor for metadata retrieval. Implementations know how to source transaction attributes, whether from configuration, metadata attributes at source level (such as Java 5 annotations), or anywhere else" />
      <item value="within" />
      <item value="Invocation" />
      <item value="determine Transaction Attribute" />
      <item value="get Most Specific Method" />
      <item value="Introduction Advisor" />
      <item value="this is the maximum time that excess idle threads * will wait for new tasks before terminating." />
      <item value="The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue" />
      <item value="Try immediate barge, backing up to normal * acquire on failure" />
      <item value="fair" />
      <item value="Î©fair" />
      <item value="has Queued Predecessors" />
      <item value="Unlinks" />
      <item value="successor" />
      <item value="acquire" />
      <item value="This node has already set status asking a release * to signal it, so it can safely park." />
      <item value="acquire Queued" />
      <item value="add Waiter" />
      <item value="The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block" />
      <item value="The successor of this node is (or will soon be) * blocked (via park)," />
      <item value="waitStatus value to indicate successor's thread needs unparking" />
      <item value="indicate" />
      <item value="Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor." />
      <item value="park" />
      <item value="should Park After Failed Acquire" />
      <item value="EXCLUSIVE" />
      <item value="So the currently released * contender thread may need to rewait" />
      <item value="it only gives the right to contend" />
      <item value="contend" />
      <item value="guarantee" />
      <item value="The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and * Hagersten" />
      <item value="Craig, Landin, and * Hagersten" />
      <item value="Craig" />
      <item value="its waitStatus is guaranteed not to be * CANCELLED" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1383" />
        <entry key="ENGLISH" value="1383" />
        <entry key="DANISH" value="7" />
        <entry key="GERMAN" value="6" />
        <entry key="FRENCH" value="8" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="7" />
        <entry key="HUNGARIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>