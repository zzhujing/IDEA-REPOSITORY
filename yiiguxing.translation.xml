<application>
  <component name="AppStorage">
    <histories>
      <item value="exclusive mode" />
      <item value="exclusive" />
      <item value="AbstractQueuedSynchronizer" />
      <item value="Queue" />
      <item value="semaphore" />
      <item value="The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of waiting, nor is it required to support interruption of the actual suspension of the thread. An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface. As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread. An implementation should document this behav" />
      <item value="or not requiring a lock to be held * when performing notifications" />
      <item value="guaranteed ordering for notifications" />
      <item value="guaranteed" />
      <item value="semantics" />
      <item value="behavior" />
      <item value="e; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per obj" />
      <item value="factors out" />
      <item value="forget" />
      <item value="forgot" />
      <item value="CAPTCHA" />
      <item value="CAPTHER" />
      <item value="Spinning" />
      <item value="退出" />
      <item value="back up" />
      <item value="离职" />
      <item value="已成交" />
      <item value="intention" />
      <item value="高意向" />
      <item value="多线程" />
      <item value="gender" />
      <item value="Ωgender" />
      <item value="销售员" />
      <item value="销售" />
      <item value="Chronology" />
      <item value="Instantiation of utility class 'SingletonObject1'" />
      <item value="equivalent" />
      <item value="judge Dns State" />
      <item value="Inheritable" />
      <item value="A hint to the scheduler that the current thread is willing to yield * its current use of a processor. The scheduler is free to ignore this * hint. * * &lt;p&gt; Yield is a heuristic attempt to improve relative progression * between threads that would otherwise over-utilise a CPU. Its use * should be combined with detailed profiling and benchmarking to * ensure that it actually has the desired effect. * * &lt;p&gt; It is rarely appropriate to use this method. It may be useful * for debugging or testing purposes, where it may help to reproduce * bugs due to race conditions. It may also be useful when designing * concurrency control constructs such as the ones in the * {@link java.util.concurrent.locks} package." />
      <item value="particular" />
      <item value="park" />
      <item value="get Universe" />
      <item value="This implementation iterates over this collection, checking each * element returned by the iterator in turn to see if it's contained * in the specified collection. If it's not so contained, it's removed * from this collection with the iterator's {@code remove} method." />
      <item value="Retains" />
      <item value="差距" />
      <item value="差值" />
      <item value="usable bits of normal node hash" />
      <item value="usable" />
      <item value="spread" />
      <item value="CLR" />
      <item value="UNTREEIFY THRESHOLD" />
      <item value="cified position in this li" />
      <item value="huge Capacity" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1345" />
        <entry key="ENGLISH" value="1346" />
        <entry key="DANISH" value="6" />
        <entry key="GERMAN" value="6" />
        <entry key="FRENCH" value="8" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="7" />
        <entry key="HUNGARIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>