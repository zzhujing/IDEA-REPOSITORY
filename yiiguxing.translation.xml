<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="474" />
    <option name="newTranslationDialogWidth" value="1510" />
    <option name="newTranslationDialogX" value="784" />
    <option name="newTranslationDialogY" value="736" />
    <histories>
      <item value="These can be exported as desired into classes using an {@code AbstractQueuedSynchronizer} for their synchronization mechanics." />
      <item value="exported" />
      <item value="instrumentation&#10;&#10;" />
      <item value="instrumentationt&#10;" />
      <item value="inspection&#10;" />
      <item value="so if this constraint" />
      <item value="so if this consta" />
      <item value="constraint&#10;" />
      <item value=". No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of AbstractQueuedSynchronizer.ConditionObject depends of course on the semantics of its synchronizer implementation.&#10;" />
      <item value="otherwise&#10;" />
      <item value="and acquire, given this saved state value, eventually restores this object to its previous acquired stat&#10;" />
      <item value="and acquire, given this saved state value, eventually restores this object to its previous acquired stat" />
      <item value="method release invoked with the current getState value fully releases this object&#10;" />
      <item value=", method release invoked with the current getState value fully releases this object&#10;" />
      <item value="held with respect to the current thread&#10;" />
      <item value="held with respect to the cu" />
      <item value="held with respect to&#10;" />
      <item value="held with" />
      <item value="This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively reports whether synchronization is exclusively held with respect to the current threa&#10;" />
      <item value="come into play&#10;" />
      <item value="come into&#10;" />
      <item value=" This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well&#10;&#10;" />
      <item value=" This class does not &quot;understand&quot; these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as we&#10;" />
      <item value="mechanical&#10;" />
      <item value="attempted acquires by other threads cannot succeed." />
      <item value="attempted" />
      <item value="either or both a default &lt;em&gt;exclusive&lt;em&gt; mode and a &lt;em&gt;shared&lt;em&gt; mode" />
      <item value="either or both" />
      <item value="appropriate" />
      <item value="but only the atomically updated {@code int} value manipulated using methods {@link getState}, {@link setState} and {@link compareAndSetState} is tracked with respect to synchronization." />
      <item value="manipulated" />
      <item value="maintains&#10;" />
      <item value="maintain&#10;" />
      <item value="Subclasses can maintain other state fields" />
      <item value="the other methods in this class carry out all queuing and blocking mechanics" />
      <item value="carry out" />
      <item value="Given these" />
      <item value="and which define what that state means in terms of this object being acquired or released" />
      <item value="Switch label 'APPLE' is the only reachable in the whole switch &#10;" />
      <item value="梨子&#10;" />
      <item value="PAIR" />
      <item value="类型推断&#10;" />
      <item value="tui" />
      <item value="indent" />
      <item value="incidental" />
      <item value="strip Indent" />
      <item value="确切的&#10;" />
      <item value="确切的&#10;&#10;" />
      <item value="fence" />
      <item value="state&#10;" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="4956" />
        <entry key="ENGLISH" value="4949" />
        <entry key="CHINESE_CLASSICAL" value="1" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="8" />
        <entry key="GERMAN" value="9" />
        <entry key="FRENCH" value="16" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="4" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALAY" value="1" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="SWEDISH" value="3" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1631461123710" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>