<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="474" />
    <option name="newTranslationDialogWidth" value="1510" />
    <option name="newTranslationDialogX" value="689" />
    <option name="newTranslationDialogY" value="756" />
    <histories>
      <item value="potential" />
      <item value="However, building a pipeline of mutable interceptors that depend on the output of the previous interceptor is discouraged, because of potential side-effects caused by interceptors potentially failing to modify the record and throwing an exceptio" />
      <item value="discouraged" />
      <item value="discouraged&#10;" />
      <item value="Similarly, it is up to interceptor implementation to ensure that correct topic/partition is returned in ProducerRecord. Most often, it should be the same topic/partition from 'record&#10;" />
      <item value=" Consequently, key and value transformation done in onSend() needs to be consistent: same key and value should mutate to the same (modified) key and value. Otherwise, log compaction would not work as expected.&#10;" />
      <item value="When used as part of a transaction, it is not necessary to define a callback or check the result of the future in order to detect errors from send. If any of the send calls failed with an irrecoverable error, the final commitTransaction() call will fail and throw the exception from the last failed send. When this happens, your application should call abortTransaction() to reset the state and continue to send data.&#10;Some transactional send errors cannot be resolved with a call to abortTransaction(). In particular, if a transactional send finishes with a ProducerFencedException, a org.apache.kafka.common.errors.OutOfOrderSequenceException, a org.apache.kafka.common.errors.UnsupportedVersionException, or an AuthorizationException, then the only option left is to call close(). Fatal errors cause the producer to enter a defunct state in which future API calls will continue to raise the same underyling error wrapped in a new KafkaException.&#10;It is a similar picture when idempotence is enabled, but no transactional.id has been configured. In this case, org.apache.kafka.common.errors.UnsupportedVersionException and AuthorizationException are considered fatal errors. However, ProducerFencedException does not need to be handled. Additionally, it is possible to continue sending after receiving an org.apache.kafka.common.errors.OutOfOrderSequenceException, but doing so can result in out of order delivery of pending messages. To ensure proper ordering, you should close the producer and create a new instance.&#10;If the message format of the destination topic is not upgraded to 0.11.0.0, idempotent and transactional produce requests will fail with an org.apache.kafka.common.errors.UnsupportedForMessageFormatException error. If this is encountered during a transaction, it is possible to abort and continue. But note that future sends to the same topic will continue receiving the same exception until the topic is upgraded.&#10;" />
      <item value="When used as part of a transaction, it is not necessary to define a callback or check the result of the future in order to detect errors from send. If any of the send calls failed with an irrecoverable error, the final commitTransaction() call will fail and throw the exception from the last failed send. When this happens, your application should call abortTransaction() to reset the state and continue to send data.&#10;Some transactional send errors cannot be resolved with a call to abortTransaction(). In particular, if a transactional send finishes with a ProducerFencedException, a org.apache.kafka.common.errors.OutOfOrderSequenceException, a org.apache.kafka.common.errors.UnsupportedVersionException, or an AuthorizationException, then the only option left is to call close(). Fatal errors cause the producer to enter a defunct state in which future API calls will continue to raise the same underyling error wrapped in a new KafkaException.&#10;" />
      <item value="e in order to detect errors from send.&#10;" />
      <item value="guaranteed&#10;" />
      <item value="simulate" />
      <item value="The send is asynchronous and this method will return immediately once the record has been stored in the buffer of records waiting to be sent&#10;" />
      <item value="The send is asynchronous and this method will return immediately once the record has been stored in the buffer of records waiting to be sent" />
      <item value="The send is asynchronous and this method will return immediately once the record has been stored in the buffer of records waiting to be sent、" />
      <item value="手动结束&#10;" />
      <item value="强制" />
      <item value="失效&#10;" />
      <item value="extract Activities" />
      <item value="newest" />
      <item value="closely" />
      <item value="handle Counting Down" />
      <item value="倒计时&#10;" />
      <item value="dao" />
      <item value="countdown&#10;" />
      <item value="dao'ji'shi" />
      <item value="到吉斯&#10;" />
      <item value="dao'ji" />
      <item value="还可以拼团人数&#10;" />
      <item value="还已经拼团人数&#10;" />
      <item value="还已经pin" />
      <item value="还可以&#10;" />
      <item value="还可以" />
      <item value="distance Nums Of Success" />
      <item value="距离" />
      <item value="距离成功个数" />
      <item value="距离成功" />
      <item value="距离互动开始时间&#10;" />
      <item value="剩余活动结束时间&#10;" />
      <item value="essential&#10;" />
      <item value="declare the transaction only execute in single local RM but the transaction need to ensure records to update(or select for update) is not in global transaction middle stage use this annotation instead of GlobalTransaction in the situation mentioned above will help performance.&#10;" />
      <item value="高级功能&#10;" />
      <item value="gao" />
      <item value="hello world&#10;" />
      <item value="高级&#10;" />
      <item value="高级功能&#10;&#10;" />
      <item value="高级功能" />
      <item value="layui-word-aux" />
      <item value="truncated" />
      <item value="invaild&#10;" />
      <item value="july&#10;" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="4250" />
        <entry key="ENGLISH" value="4240" />
        <entry key="CHINESE_CLASSICAL" value="1" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="8" />
        <entry key="GERMAN" value="8" />
        <entry key="FRENCH" value="15" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="6" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1626510719287" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
  </component>
</application>