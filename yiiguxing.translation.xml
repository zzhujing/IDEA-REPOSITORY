<application>
  <component name="AppStorage">
    <histories>
      <item value="remove Manual Singleton Name" />
      <item value="actual * type of underlying resource" />
      <item value="underlying" />
      <item value="actual" />
      <item value="Input Stream Source" />
      <item value="eager" />
      <item value="// Do not allow eager init for type matching in case of a prioritized post-processor." />
      <item value="optimized" />
      <item value="individual" />
      <item value="instantiated" />
      <item value="Presents a view onto an annotation where attribute values may * have been &quot;merged&quot; from different source values" />
      <item value="A single merged annotation returned from a MergedAnnotations collection. Presents a view onto an annotation where attribute values may have been &quot;merged&quot; from different source values. Attribute values may be accessed using the various get methods. For example, to access an int attribute the getInt(String) method would be used. Note that attribute values are not converted when accessed. For example, it is not possible to call getString(String) if the underlying attribute is an int. The only exception to this rule is Class and Class[] values which may be accessed as String and String[] respectively to prevent potential early class initialization. If necessary, a MergedAnnotation can be synthesized back into an actual Annotation." />
      <item value="intended" />
      <item value="corresponding" />
      <item value="canonical" />
      <item value="intern" />
      <item value="Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking" />
      <item value="Release action for shared mode -- signals successor and ensures propagation. (Note: For exclusive mode, release just amounts to calling unparkSuccessor of head if it needs signal.)" />
      <item value="If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate" />
      <item value="compose" />
      <item value="run After Both Async" />
      <item value="Queries whether any threads have been waiting to acquire longer * than the current thread" />
      <item value="Queries whether any threads have been waiting to acquire longer than the current thread. An invocation of this method is equivalent to (but may be more efficient than): getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads() Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that some other thread will acquire before the current thread. Likewise, it is possible for another thread to win a race to enqueue after this method has returned false, due to the queue being empty. This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer's tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:" />
      <item value="a queued thread preceding the * current thread" />
      <item value="join" />
      <item value="fork" />
      <item value="Privileged Thread Factory" />
      <item value="waiting if necessary up to the specified wait * time if none are yet present." />
      <item value="sketch" />
      <item value="associated" />
      <item value="on Advance" />
      <item value="Phaser" />
      <item value="Cyclic Barrier" />
      <item value="HASH BITS" />
      <item value="0 x 7 fffffff" />
      <item value="Strategy interface used by TransactionInterceptor for metadata retrieval. Implementations know how to source transaction attributes, whether from configuration, metadata attributes at source level (such as Java 5 annotations), or anywhere else" />
      <item value="within" />
      <item value="Invocation" />
      <item value="determine Transaction Attribute" />
      <item value="get Most Specific Method" />
      <item value="Introduction Advisor" />
      <item value="this is the maximum time that excess idle threads * will wait for new tasks before terminating." />
      <item value="The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue" />
      <item value="Try immediate barge, backing up to normal * acquire on failure" />
      <item value="fair" />
      <item value="Î©fair" />
      <item value="has Queued Predecessors" />
      <item value="Unlinks" />
      <item value="successor" />
      <item value="acquire" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1398" />
        <entry key="ENGLISH" value="1399" />
        <entry key="DANISH" value="7" />
        <entry key="GERMAN" value="6" />
        <entry key="FRENCH" value="8" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="7" />
        <entry key="HUNGARIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>