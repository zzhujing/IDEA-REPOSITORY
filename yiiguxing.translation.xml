<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="447" />
    <option name="newTranslationDialogWidth" value="1510" />
    <option name="newTranslationDialogX" value="2" />
    <option name="newTranslationDialogY" value="526" />
    <histories>
      <item value="prescription" />
      <item value="时效&#10;" />
      <item value="Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers." />
      <item value="OccupancyFraction&#10;" />
      <item value="Occupancy" />
      <item value="Occupan" />
      <item value="O" />
      <item value="Commits the ongoing transaction. This method will flush any unsent records before actually committing the transaction. Further, if any of the send(ProducerRecord) calls which were part of the transaction hit irrecoverable errors, this method will throw the last received exception immediately and the transaction will not be committed. So all send(ProducerRecord) calls in a transaction must succeed in order for this method to succeed. Note that this method will raise TimeoutException if the transaction cannot be committed before expiration of max.block.ms. Additionally, it will raise InterruptException if interrupted. It is safe to retry in either case, but it is not possible to attempt a different operation (such as abortTransaction) since the commit may already be in the progress of completing. If not retrying, the only option is to close the producer." />
      <item value="When running in a transaction, send the consumer offset(s) to the transaction. The group id is obtained from org.springframework.kafka.support.KafkaUtils.getConsumerGroupId(). It is not necessary to call this method if the operations are invoked on a listener container thread (and the listener container is configured with a org.springframework.kafka.transaction.KafkaAwareTransactionManager) since the container will take care of sending the offsets to the transaction." />
      <item value="Execute some arbitrary operation(s) on the operations and return the result. The operations are invoked within a local transaction and do not participate in a global transaction (if present)." />
      <item value="and do not participate in a global transaction (if present)." />
      <item value="logistic List" />
      <item value="PretenureSizeThreshold" />
      <item value="Occupancy Fraction&#10;" />
      <item value="Expunge a stale entry by rehashing any possibly colliding entries lying between staleSlot and the next null slot. This also expunges any other stale entries encountered before the trailing null" />
      <item value="encounter" />
      <item value="expunge Stale Entry" />
      <item value="replace Stale Entry" />
      <item value="full Try Acquire Shared" />
      <item value="spread" />
      <item value="Table initialization and resizing control. When negative, the table is being initialized or resized: -1 for initialization, else -(1 + the number of active resizing threads). Otherwise, when table is null, holds the initial table size to use upon creation, or 0 for default. After initialization, holds the next element count value upon which to resize the table." />
      <item value="Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http:en.wikipedia.orgwikiPoisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) factorial(k)). The first values are:" />
      <item value="rarely" />
      <item value="Caller Sensitive" />
      <item value="ephemeral" />
      <item value="inhibit interrupts until runWorker" />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. We implement a simple non-reentrant mutual exclusion lock rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker)." />
      <item value="Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution" />
      <item value="Before running any task, the lock is acquired to prevent other pool interrupts while the task is executing, and then we ensure that unless pool is stopping, this thread does not have its interrupt set" />
      <item value="可见性&#10;" />
      <item value="ke" />
      <item value="Topic" />
      <item value="elapsed&#10;" />
      <item value="elapsed" />
      <item value="缓存与数据库一致性&#10;" />
      <item value="Round Robin Load Balancer" />
      <item value="轮询&#10;" />
      <item value="轮训&#10;" />
      <item value="Rounrobin Load Balancer" />
      <item value="materialize" />
      <item value="BORDER" />
      <item value="Targeter" />
      <item value="Some headers, such as Accept-Language can be sent by clients as several headers each with a different value rather than sending the header as a comma separated list" />
      <item value="inherit Parent Context" />
      <item value="is Independent" />
      <item value="Client Http Request Execution" />
      <item value="disambiguation" />
      <item value="Registration" />
      <item value="The initial locations can be influenced via th" />
      <item value="Initialize the given {@link BootstrapRegistry} with any required registrations." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="7028" />
        <entry key="ENGLISH" value="7028" />
        <entry key="CHINESE_CLASSICAL" value="1" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="9" />
        <entry key="GERMAN" value="10" />
        <entry key="FRENCH" value="19" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="4" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALAY" value="2" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="9" />
        <entry key="SWEDISH" value="4" />
        <entry key="SERBIAN" value="1" />
        <entry key="SLOVAK" value="3" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="6" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1653269201258" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>