<application>
  <component name="AppStorage">
    <histories>
      <item value="刷卡器" />
      <item value=" 信号强度" />
      <item value="状态" />
      <item value="status" />
      <item value="stats" />
      <item value="Property" />
      <item value="所属物业" />
      <item value="物业" />
      <item value="advance" />
      <item value="Phaser" />
      <item value="until" />
      <item value="The effects of invoking * arrival, registration, and waiting methods on this phaser from * within {@code onAdvance} are unspecified and should not be * relied on." />
      <item value="prevailing" />
      <item value="The arguments to this method provide the state of the phaser * prevailing for the current transition" />
      <item value="in which case no advance * occurs" />
      <item value="this phaser will be set to a final termination state * upon advance" />
      <item value="when all other * waiting parties are dormant" />
      <item value="This method is invoked * upon arrival of the party advancing this phaser" />
      <item value="upon arrival of the party advancing this phaser" />
      <item value="in which case the prevailing phase prior to termination * may be obtained via {@code getPhase() + Integer.MIN_VALUE}." />
      <item value="Upon termination, the phase number is negative" />
      <item value="第二次" />
      <item value="Advance" />
      <item value="on Advance" />
      <item value="verridable method to perform an action upon impending phase * advance, and to control termination. This method is invoked * upon arrival of the party advancing this phaser (when all other * waiting parties are dormant)." />
      <item value="adance" />
      <item value="automatic" />
      <item value="automiclly" />
      <item value="自动" />
      <item value="get Phase" />
      <item value="Phaser Test" />
      <item value="reusable" />
      <item value="Forks the given tasks, returning when {@code isDone} holds for * each task or an (unchecked) exception is encountered, in which * case the exception is rethrown. If more than one task * encounters an exception, then this method throws any one of * these exceptions. If any task encounters an exception, the * other may be cancelled. However, the execution status of * individual tasks is not guaranteed upon exceptional return. The * status of each task may be obtained using {@link * #getException()} and related methods to check if they have been * cancelled, completed normally or exceptionally, or left * unprocessed." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method. As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods.&#10;Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait.&#10;A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method.&#10;As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="factors" />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods." />
      <item value="factors out the" />
      <item value="distinct" />
      <item value="into distinct objects to * give the effect of having multiple wait-sets per object, by * combining them with the use of arbitrary {@link Lock} implementations. * Where a {@code Lock} replaces the use of {@code synchronized} methods * and statements, a {@code Condition} replaces the use of the Object * monitor methods." />
      <item value="{@code Condition} factors out the {@code Object} monitor * methods ({@link Object#wait() wait}, {@link Object#notify notify} * and {@link Object#notifyAll notifyAll}) into distinct objects to * give the effect of having multiple wait-sets per object" />
      <item value="Returns true if the lock has not been exclusively acquired * since issuance of the given stamp" />
      <item value="exclusively" />
      <item value="Returns true if the lock has not been exclusively acquired * since issuance of the given stamp. Always returns false if the * stamp is zero. Always returns true if the stamp represents a * currently held lock. Invoking this method with a value not * obtained from {@link #tryOptimisticRead} or a locking method * for this lock has no defined effect or result." />
      <item value="Returns true if the lock has not been exclusively acquired" />
      <item value="eturns a stamp that can later be validated, or zero" />
      <item value="Deque" />
      <item value="An implementation can favor responding to an interrupt over normal * method return in response to a signal. In that case the implementation * must ensure that the signal is redirected to another waiting thread, if * there is one" />
      <item value="In all cases, before this method can return the current thread must * re-acquire the lock associated with this condition. When the * thread returns it is &lt;em&gt;guaranteed&lt;/em&gt; to hold this lock" />
      <item value="The lock associated with this {@code Condition} is atomically * released and the current thread becomes disabled for thread scheduling * purposes and lies dormant until &lt;em&gt;one&lt;/em&gt; of four things happens" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="142" />
        <entry key="ENGLISH" value="143" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>