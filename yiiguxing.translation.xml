<application>
  <component name="AppStorage">
    <histories>
      <item value="park" />
      <item value="should Park After Failed Acquire" />
      <item value="EXCLUSIVE" />
      <item value="So the currently released * contender thread may need to rewait" />
      <item value="it only gives the right to contend" />
      <item value="contend" />
      <item value="guarantee" />
      <item value="The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and * Hagersten" />
      <item value="Craig, Landin, and * Hagersten" />
      <item value="Craig" />
      <item value="its waitStatus is guaranteed not to be * CANCELLED" />
      <item value="is Held Exclusively" />
      <item value="exclusive mode" />
      <item value="exclusive" />
      <item value="AbstractQueuedSynchronizer" />
      <item value="Queue" />
      <item value="semaphore" />
      <item value="The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of waiting, nor is it required to support interruption of the actual suspension of the thread. An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface. As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread. An implementation should document this behav" />
      <item value="or not requiring a lock to be held * when performing notifications" />
      <item value="guaranteed ordering for notifications" />
      <item value="guaranteed" />
      <item value="semantics" />
      <item value="behavior" />
      <item value="e; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per obj" />
      <item value="factors out" />
      <item value="forget" />
      <item value="forgot" />
      <item value="CAPTCHA" />
      <item value="CAPTHER" />
      <item value="Spinning" />
      <item value="退出" />
      <item value="back up" />
      <item value="离职" />
      <item value="已成交" />
      <item value="intention" />
      <item value="高意向" />
      <item value="多线程" />
      <item value="gender" />
      <item value="Ωgender" />
      <item value="销售员" />
      <item value="销售" />
      <item value="Chronology" />
      <item value="Instantiation of utility class 'SingletonObject1'" />
      <item value="equivalent" />
      <item value="judge Dns State" />
      <item value="Inheritable" />
      <item value="A hint to the scheduler that the current thread is willing to yield * its current use of a processor. The scheduler is free to ignore this * hint. * * &lt;p&gt; Yield is a heuristic attempt to improve relative progression * between threads that would otherwise over-utilise a CPU. Its use * should be combined with detailed profiling and benchmarking to * ensure that it actually has the desired effect. * * &lt;p&gt; It is rarely appropriate to use this method. It may be useful * for debugging or testing purposes, where it may help to reproduce * bugs due to race conditions. It may also be useful when designing * concurrency control constructs such as the ones in the * {@link java.util.concurrent.locks} package." />
      <item value="particular" />
      <item value="get Universe" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1353" />
        <entry key="ENGLISH" value="1354" />
        <entry key="DANISH" value="7" />
        <entry key="GERMAN" value="6" />
        <entry key="FRENCH" value="8" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="PORTUGUESE" value="4" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="7" />
        <entry key="HUNGARIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>