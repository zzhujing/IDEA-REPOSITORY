<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="1034" />
    <option name="newTranslationDialogY" value="452" />
    <histories>
      <item value="this" />
      <item value="supertype" />
      <item value="associated with none. In any case, it may be invoked through an associated method handle called its {@linkplain dynamicInvoker dynamic invoker}." />
      <item value="several" />
      <item value="An {@code invokedynamic} instruction linked to a {@code CallSite} delegates all calls to the site's current target" />
      <item value="abstract" />
      <item value="A {@code CallSite} is a holder for a variable {@link MethodHandle}, which is called its {@code target}. An {@code invokedynamic} instruction linked to a {@code CallSite} delegates all calls to the site's current target. A {@code CallSite} may be associated with several {@code invokedynamic} instructions, or it may be &quot;free floating&quot;, associated with none. In any case, it may be invoked through an associated method handle called its {@linkplain dynamicInvoker dynamic invoker}." />
      <item value="Produces a method handle equivalent to an invokedynamic instruction" />
      <item value="累加器&#10;" />
      <item value="Assembler" />
      <item value="particular" />
      <item value="introduce&#10;" />
      <item value="Ω" />
      <item value="designated" />
      <item value="defensive" />
      <item value="bridge" />
      <item value="birdge Method" />
      <item value="the take over userid" />
      <item value="the hand over userid" />
      <item value="FEMALE" />
      <item value="Camel Case Splitting Field Naming Strategy" />
      <item value="Camel Case Abbreviating Field Naming Strategy" />
      <item value="introduce" />
      <item value="intro" />
      <item value="on behalf of" />
      <item value="on nehalf of" />
      <item value="on nehalf " />
      <item value="on" />
      <item value="apparently First Queued Is Exclusive" />
      <item value="writer Should Block" />
      <item value="has Queued Threads" />
      <item value="has Queued Predecessors" />
      <item value="Queries whether any threads have been waiting to acquire longer than the current thread." />
      <item value="waitStatus value to indicate the next acquireShared should unconditionally propagate." />
      <item value="waitStatus value to indicate thread is waiting on condition" />
      <item value="waitStatus value to indicate successor's thread needs unparking" />
      <item value="waitStatus must be 0 or PROPAGATE. Indicate that we need a signal, but don't park yet. Caller will need to retry to make sure it cannot acquire before parking" />
      <item value="SIGNAL" />
      <item value="This node has already set status asking a release to signal it, so it can safely park." />
      <item value="The null check could be elided, but is present to help the VM" />
      <item value="elided" />
      <item value="predecessor" />
      <item value="Because condition queues are accessed only when holding in exclusive mode, we just need a simple linked queue to hold nodes while they are waiting on conditions" />
      <item value="precede" />
      <item value="diagnostic" />
      <item value="&lt;p&gt;If this stream is ordered then the longest prefix is a contiguous sequence of elements of this stream that match the given predicate. The first element of the sequence is the first element of this stream, and the element immediately following the last element of the sequence does not match the given predicate." />
      <item value="Returns, if this stream is ordered, a stream consisting of the longest prefix of elements taken from this stream that match the given predicate. Otherwise returns, if this stream is unordered, a stream consisting of a subset of elements taken from this stream that match the given predicate" />
      <item value="consisting" />
      <item value="a stream consisting of the remaining elements of this stream after dropping a subset of elements that match the given predicate" />
      <item value="Returns, if this stream is ordered, a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2622" />
        <entry key="ENGLISH" value="2623" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="DANISH" value="7" />
        <entry key="GERMAN" value="8" />
        <entry key="FRENCH" value="14" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="5" />
        <entry key="PORTUGUESE" value="6" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1611811010167" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>