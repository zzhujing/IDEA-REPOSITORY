<application>
  <component name="AppStorage">
    <histories>
      <item value="Temporal" />
      <item value="@RequestParam-annotated method arguments. This excludes Map params where the annotation does not specify a name. See RequestParamMapMethodArgumentResolver instead for such params" />
      <item value="Return a variant of this {@code MethodParameter} which points to the * same parameter but one nesting level deeper" />
      <item value="EMPTY ARGS" />
      <item value="underlying" />
      <item value="Invocable" />
      <item value="Invocable Handler Method" />
      <item value="redirect" />
      <item value="Ωredirect" />
      <item value="restrict Default Supported Methods" />
      <item value="Given a pattern and a full path, determine the pattern-mapped part. This method is supposed to find out which part of the path is matched dynamically through an actual pattern, that is, it strips off a statically defined leading path from the given full path, returning only the actually pattern-matched part of the path. For example: For &quot;myroot/*.html&quot; as pattern and &quot;myroot/myfile.html&quot; as full path, this method should return &quot;myfile.html&quot;. The detailed determination rules are specified to this PathMatcher's matching strategy. A simple implementation may return the given full path as-is in case of an actual pattern, and the empty String in case of the pattern not containing any dynamic parts (i.e. the pattern parameter being a static path that wouldn't qualify as an actual pattern). A sophisticated implementation will differentiate between the static parts and the dynamic parts of the given path pattern." />
      <item value="extract Path Within Pattern" />
      <item value="uri Template Variables" />
      <item value="use Trailing Slash Match" />
      <item value="Typically" />
      <item value="Bean name prefix for target beans behind scoped proxies. Used to exclude those targets from handler method detection, in favor of the corresponding proxies. We're not checking the autowire-candidate status here, which is how the proxy target filtering problem is being handled at the autowiring level, since autowire-candidate may have been turned to false for other reasons, while still expecting the bean to be eligible for handler methods. Originally defined in org.springframework.aop.scope.ScopedProxyUtils but duplicated here to avoid a hard dependency on the spring-aop module." />
      <item value="synthetic" />
      <item value="sanitized Path Within App" />
      <item value="Path Exposing Handler Interceptor" />
      <item value="raw" />
      <item value="get Path Within Application" />
      <item value="matching Beans" />
      <item value="indicate" />
      <item value="indicates Multiple Beans" />
      <item value="against" />
      <item value="Qualifier" />
      <item value="recommended" />
      <item value="render" />
      <item value="Web Async Manager" />
      <item value="inheritable" />
      <item value="register Callable In特" />
      <item value="get Session Mutex" />
      <item value="mutex" />
      <item value="regardless of the outcome" />
      <item value="regardless" />
      <item value="PATCH" />
      <item value="Interface for web-based theme resolution strategies that allows for * both theme resolution via the request and theme modification via * request and response" />
      <item value="installed" />
      <item value="prior to being refreshed" />
      <item value="prior" />
      <item value="Called by the servlet container to indicate to a servlet that the servlet * is being placed into service" />
      <item value="init Strategies" />
      <item value="treats" />
      <item value="tokenize To String Array" />
      <item value="responsibility" />
      <item value="intentionally" />
      <item value="SCI processing is performed regardless of the setting of metadata-complete. SCI processing can be controlled per JAR file via fragment ordering. If absolute ordering is defined, then only the JARs included in the ordering will be processed for SCIs. To disable SCI processing completely, an empty absolute ordering may be defined" />
      <item value="via" />
      <item value="occur" />
      <item value="indicates" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1002" />
        <entry key="ENGLISH" value="1003" />
        <entry key="DANISH" value="5" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="7" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="6" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>