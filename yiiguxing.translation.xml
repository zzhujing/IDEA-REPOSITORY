<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="256" />
    <option name="newTranslationDialogWidth" value="896" />
    <option name="newTranslationDialogX" value="676" />
    <option name="newTranslationDialogY" value="587" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Utility that can be used to invoke lambdas in a safe way. Primarily designed to help support generically typed callbacks where {@link ClassCastException class cast exceptions} need to be dealt with due to class erasure." />
      <item value="is Candidate Class" />
      <item value="ultimate" />
      <item value="ultimate Target Class" />
      <item value="Post-process the given merged bean definition for the specified bean." />
      <item value="Eager" />
      <item value="EXCLUSION" />
      <item value="Independent" />
      <item value="is Independent" />
      <item value="consider" />
      <item value="Considers" />
      <item value="consider Inherited" />
      <item value="Can use {@link CandidateComponentsIndex the index} if it is available of scans the classpath otherwise" />
      <item value="Splice onto queue and try to set waitStatus of predecessor to indicate that thread is (probably) waiting. If cancelled or attempt to set waitStatus fails, wake up to resync (in which case the waitStatus can be transiently and harmlessly wrong)." />
      <item value="Splice" />
      <item value="Removes and transfers nodes until hit non-cancelled one or null. Split out from signal in part to encourage compilers to inline the case of no waiters." />
      <item value="Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue" />
      <item value="successor" />
      <item value="is Held Exclusively" />
      <item value="set Head And Propagate" />
      <item value="Additionally, we must loop in case a new node is added while we are doing this." />
      <item value="upon release" />
      <item value="Ensure that a release propagates, even if there are other in-progress acquiresreleases. This proceeds in the usual way of trying to unparkSuccessor of head if it needs signal" />
      <item value="propagates" />
      <item value="signals successor and ensures propagation" />
      <item value="Support for three different return values enables this method to be used in contexts where acquires only sometimes act exclusively" />
      <item value="and a positive value if acquisition in shared mode succeeded and subsequent shared-mode acquires might also succeed" />
      <item value="negative" />
      <item value="but no subsequent shared-mode acquire can succeed" />
      <item value="the acquire argument. This value is always the one passed to an acquire method, or is the value saved on entry to a condition wait. The value is otherwise uninterpreted and can represent anything you like" />
      <item value="This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread." />
      <item value="his method is always invoked by the thread p ire. If this method reports failure, the ac queue the thread, if it is not already queue alled by a release from some other thread." />
      <item value="This method should query if the state of the object permits it to be acquired in the shared mode, and if so to acquire it." />
      <item value="approximate" />
      <item value="elapsed" />
      <item value="分隔符&#10;" />
      <item value="协同&#10;" />
      <item value="as well as" />
      <item value="Used by condition wait methods as well as acquire" />
      <item value="predecessor" />
      <item value="racy" />
      <item value="possibly racy reads" />
      <item value="Returns a stamp that can later be validated, or zero if exclusively locked." />
      <item value="Invoking this method with a value not obtained from {@link tryOptimisticRead} or a locking method for this lock has no defined effect or result." />
      <item value="hypot" />
      <item value="升级&#10;" />
      <item value="降级&#10;" />
      <item value="If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available." />
      <item value="atomically performs one of the following actions" />
      <item value="performs" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="2945" />
        <entry key="ENGLISH" value="2946" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="DANISH" value="8" />
        <entry key="GERMAN" value="8" />
        <entry key="FRENCH" value="14" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="2" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="5" />
        <entry key="PORTUGUESE" value="6" />
        <entry key="SWEDISH" value="2" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1615017601272" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>