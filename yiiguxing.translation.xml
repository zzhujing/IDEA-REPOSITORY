<application>
  <component name="AppStorage">
    <histories>
      <item value="literal" />
      <item value="Property resource configurer that overrides bean property values in an application context definition. It pushes values from a properties file into bean definitions. Configuration lines are expected to be of the following form" />
      <item value="Note that the context definition &lt;i&gt;is not&lt;/i&gt; aware of being overridden; * so this is not immediately obvious when looking at the XML definition file" />
      <item value="In contrast to PropertyPlaceholderConfigurer, the original definition can have default * values or no values at all for such bean properties. If an overriding properties file does * not have an entry for a certain bean property, the default context definition is used" />
      <item value="contrast" />
      <item value="overrides" />
      <item value="Check that we're not parsing our own bean definition" />
      <item value="Bean Definition Visitor" />
      <item value="Return the originating BeanDefinition, or {@code null} if none. * Allows for retrieving the decorated bean definition, if any. * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the * originator chain to find the original BeanDefinition as defined by the user" />
      <item value="immediate originator" />
      <item value="immediate" />
      <item value="Allows for retrieving the decorated bean definition, if any." />
      <item value="retrieving" />
      <item value="Supports local properties as well, with * configurable overriding" />
      <item value="properties" />
      <item value="Base class for JavaBean-style components that need to load properties * from one or more resources" />
      <item value="overriding" />
      <item value="Dictionary" />
      <item value="use {@code org.springframework.context.support.PropertySourcesPlaceholderConfigurer} * instead which is more flexible through taking advantage of the {@link org.springframework.core.env.Environment} * and {@link org.springframework.core.env.PropertySource} mechanisms" />
      <item value="Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them!" />
      <item value="regular Post Processors" />
      <item value="for picking up proxies etc" />
      <item value="This will typically be used by application contexts to register * dependencies that are resolved in other ways" />
      <item value="typically" />
      <item value="eager-initializing" />
      <item value="any ordering semantics expressed through implementing the * {@code PriorityOrdered} or {@code Ordered} interface will be ignored for * programmatically registered post-processors. Furthermore, the * {@link org.springframework.core.annotation.Order @Order} annotation is not * taken into account for {@code BeanFactoryPostProcessor} beans" />
      <item value="violating" />
      <item value="premature" />
      <item value="Useful for custom config files targeted at system administrators that * override bean properties configured in the application context. See * {@link PropertyResourceConfigurer} and its concrete implementations for * out-of-the-box solutions that address such configuration needs" />
      <item value="underlying" />
      <item value="adapting" />
      <item value="detecting" />
      <item value="Application Listener Detector" />
      <item value="not eligible for auto-proxying" />
      <item value="eligible" />
      <item value="Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors" />
      <item value="a bean is not eligible for getting processed by all BeanPostProcessors" />
      <item value="Delegate" />
      <item value="Aware" />
      <item value="Nested Dependency Descriptor" />
      <item value="resolve Shortcut" />
      <item value="transient" />
      <item value="Find out about ambiguity: In case of the same type difference weight" />
      <item value="is Factory Method Unique" />
      <item value="raw Arguments" />
      <item value="opportunity" />
      <item value="set callbacks directly on the instance instead of in the // enhanced class (via the Enhancer) in order to avoid memory leaks" />
      <item value="avoid" />
      <item value="memory leaks" />
      <item value="ambiguous Constructors" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="816" />
        <entry key="ENGLISH" value="816" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="5" />
        <entry key="FRENCH" value="4" />
        <entry key="FINNISH" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="4" />
        <entry key="HUNGARIAN" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
  </component>
</application>