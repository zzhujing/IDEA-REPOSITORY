<application>
  <component name="AppStorage">
    <histories>
      <item value="Phaser Test" />
      <item value="reusable" />
      <item value="Forks the given tasks, returning when {@code isDone} holds for * each task or an (unchecked) exception is encountered, in which * case the exception is rethrown. If more than one task * encounters an exception, then this method throws any one of * these exceptions. If any task encounters an exception, the * other may be cancelled. However, the execution status of * individual tasks is not guaranteed upon exceptional return. The * status of each task may be obtained using {@link * #getException()} and related methods to check if they have been * cancelled, completed normally or exceptionally, or left * unprocessed." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method. As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods.&#10;Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait.&#10;A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method.&#10;As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances." />
      <item value="factors" />
      <item value="Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods." />
      <item value="factors out the" />
      <item value="distinct" />
      <item value="into distinct objects to * give the effect of having multiple wait-sets per object, by * combining them with the use of arbitrary {@link Lock} implementations. * Where a {@code Lock} replaces the use of {@code synchronized} methods * and statements, a {@code Condition} replaces the use of the Object * monitor methods." />
      <item value="{@code Condition} factors out the {@code Object} monitor * methods ({@link Object#wait() wait}, {@link Object#notify notify} * and {@link Object#notifyAll notifyAll}) into distinct objects to * give the effect of having multiple wait-sets per object" />
      <item value="Returns true if the lock has not been exclusively acquired * since issuance of the given stamp" />
      <item value="exclusively" />
      <item value="Returns true if the lock has not been exclusively acquired * since issuance of the given stamp. Always returns false if the * stamp is zero. Always returns true if the stamp represents a * currently held lock. Invoking this method with a value not * obtained from {@link #tryOptimisticRead} or a locking method * for this lock has no defined effect or result." />
      <item value="Returns true if the lock has not been exclusively acquired" />
      <item value="eturns a stamp that can later be validated, or zero" />
      <item value="Deque" />
      <item value="An implementation can favor responding to an interrupt over normal * method return in response to a signal. In that case the implementation * must ensure that the signal is redirected to another waiting thread, if * there is one" />
      <item value="In all cases, before this method can return the current thread must * re-acquire the lock associated with this condition. When the * thread returns it is &lt;em&gt;guaranteed&lt;/em&gt; to hold this lock" />
      <item value="The lock associated with this {@code Condition} is atomically * released and the current thread becomes disabled for thread scheduling * purposes and lies dormant until &lt;em&gt;one&lt;/em&gt; of four things happens" />
      <item value="associated" />
      <item value="reach a common barrier point." />
      <item value="A synchronization aid that allows one or more threads to wait until * a set of operations being performed in other threads completes." />
      <item value="aid" />
      <item value="Reentrant Lock Test" />
      <item value="typically" />
      <item value="If no permit is available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until * one of two things happens" />
      <item value="semaphore" />
      <item value="Semaphore" />
      <item value="acquire" />
      <item value="because it can be re-used after the waiting threads * are released." />
      <item value="to reach a common barrier point" />
      <item value="synchronization" />
      <item value="Cyclic Barrier Test 1" />
      <item value="Cyclic Barrier" />
      <item value="This is a one-shot phenomenon * -- the count cannot be reset" />
      <item value="绑定" />
      <item value="binding Card No" />
      <item value="bingding" />
      <item value="Purchase Controller" />
      <item value="Incompatible equality constraint: capture of ? extends CommonUserDTO and OrdinalUserDTO" />
      <item value="œ" />
      <item value="运营商" />
      <item value="所属运营商" />
      <item value="分类错误" />
      <item value="分类" />
      <item value="领用" />
      <item value="backend" />
      <item value="SequelizeDatabaseError: Data truncated for column 'type' at row 1" />
      <item value="极端" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="121" />
        <entry key="ENGLISH" value="122" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>