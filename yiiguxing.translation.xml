<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="474" />
    <option name="newTranslationDialogWidth" value="1510" />
    <option name="newTranslationDialogX" value="98" />
    <option name="newTranslationDialogY" value="527" />
    <histories>
      <item value="consider deriving" />
      <item value="the internal BeanFactory of this context is available right from the start" />
      <item value="In contrast to" />
      <item value="assume" />
      <item value="Expose AutowireCapableBeanFactory functionality for this context. &lt;p&gt;This is not typically used by application code, except for the purpose of initializing bean instances that live outside of the application context, applying the Spring bean lifecycle (fully or partly) to them. &lt;p&gt;Alternatively, the internal BeanFactory exposed by the {@link ConfigurableApplicationContext} interface offers access to the {@link AutowireCapableBeanFactory} interface too. The present method mainly serves as a convenient, specific facility on the ApplicationContext interface." />
      <item value="Alternatively" />
      <item value="purpose" />
      <item value="desired" />
      <item value="Determine whether the specified bean qualifies as an autowire candidate, to be injected into other beans which declare a dependency of matching type. &lt;p&gt;This method checks ancestor factories as well." />
      <item value="Determine whether the specified bean qualifies as an autowire candidate" />
      <item value="qualifies" />
      <item value="intended" />
      <item value="This is intended for" />
      <item value="Resolve the specified dependency against the beans defined in this factory." />
      <item value="against" />
      <item value="This is effectively a variant of {@link getBean(Class)} which preserves the bean name of the matching instance." />
      <item value="preserves" />
      <item value="uniquely matches" />
      <item value="Delegate" />
      <item value="applying the {@link org.springframework.beans.factory.DisposableBean} contract as well as registered {@link DestructionAwareBeanPostProcessor DestructionAwareBeanPostProcessors}." />
      <item value="contract" />
      <item value="The bean definition can either define a fully self-contained bean, reusing its property values, or just property values meant to be used for existing bean instances" />
      <item value="fine-grained" />
      <item value="distinct" />
      <item value="corresponding" />
      <item value="superset" />
      <item value="effectively" />
      <item value="This is essentially intended for" />
      <item value="essentially" />
      <item value="It does &lt;i&gt;not&lt;i&gt; imply traditional by-name or by-type autowiring of properties; use {@link createBean(Class, int, boolean)} for those purposes" />
      <item value="imply" />
      <item value="use {@link createBean(Class, int, boolean)} for those purposes" />
      <item value="annotated" />
      <item value="Suffix for the &quot;original instance&quot; convention when initializing an existing bean instance: to be appended to the fully-qualified bean class name, e.g. &quot;com.mypackage.MyClass.ORIGINAL&quot;, in order to enforce the given instance to be returned, i.e. no proxies etc." />
      <item value="prefer annotation-based autowiring for clearer demarcation of autowiring needs" />
      <item value="appropriate" />
      <item value="greediest constructor" />
      <item value="greediest" />
      <item value="Note that BeanFactoryAware etc and annotation-driven injection will still be applied." />
      <item value="aware&#10;" />
      <item value="externally" />
      <item value="autowire&#10;" />
      <item value="leverage" />
      <item value="stick to" />
      <item value="This subinterface of BeanFactory is not meant to be used in normal application code" />
      <item value="autowiring" />
      <item value="eagerly" />
      <item value="include Non Singletons" />
      <item value="If the object created by the FactoryBean doesn't match, the raw FactoryBean itself will be matched against the type" />
      <item value="judging" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="5259" />
        <entry key="ENGLISH" value="5260" />
        <entry key="CHINESE_CLASSICAL" value="1" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="9" />
        <entry key="GERMAN" value="9" />
        <entry key="FRENCH" value="17" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="4" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALAY" value="1" />
        <entry key="PORTUGUESE" value="7" />
        <entry key="SWEDISH" value="3" />
        <entry key="SLOVAK" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="5" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1633410219213" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>