<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="447" />
    <option name="newTranslationDialogWidth" value="1486" />
    <option name="newTranslationDialogX" value="2" />
    <option name="newTranslationDialogY" value="526" />
    <histories>
      <item value="new Array List With Expected Size" />
      <item value="scale" />
      <item value="usage Rate" />
      <item value="调整&#10;" />
      <item value="数量&#10;" />
      <item value="verify Lottery Time Overlapping" />
      <item value="交叉&#10;" />
      <item value="this sink honors downstream demand of the Subscriber, and will emit Subscriber.onError(Throwable) if there is a mismatch." />
      <item value="the lowest demand in case of multiple subscribers." />
      <item value="replay" />
      <item value="Replaying" />
      <item value="notify the caller with Sinks.EmitResult.FAIL_OVERFLOW if any of the subscribers cannot process an element, failing fast and backing off from emitting the element at all (all or nothing). From the perspective of subscribers, data is dropped and never seen but they are not terminated." />
      <item value="direct Best Effort" />
      <item value="unicast" />
      <item value="broadcast" />
      <item value="transient Errors" />
      <item value="burst&#10;" />
      <item value="indefinitely" />
      <item value="elapsed" />
      <item value="Serializes calls to onNext, onError and onComplete." />
      <item value="requesting a replenishing amount when 75% of the prefetch amount has been emitted." />
      <item value="prefetch-and-replenish" />
      <item value="Furthermore" />
      <item value="This Flux factory is useful if one wants to adapt some other multi-valued async API and not worry about cancellation and backpressure (which is handled by buffering all signals if the downstream can't keep up)" />
      <item value="Fuseable" />
      <item value="To be used by custom operators: invokes assembly Hooks pointcut given a Flux, potentially returning a new Flux. This is for example useful to activate cross-cutting concerns at assembly time, eg. a generalized checkpoint()." />
      <item value="on Assembly" />
      <item value="Because users tend to forget to request the subsciption. If the behavior is really needed, consider using subscribeWith(Subscriber). To be removed in 3.5." />
      <item value="The recommended way to learn about the Flux API and discover new operators is through the reference documentation, rather than through this javadoc (as opposed to learning more about individual operators). See the &quot;which operator do I need?&quot; appendix ." />
      <item value="The default value of defaultBufferSize may provide a useful starting point for choosing request sizes and capacities in Flow components based on expected rates, resources, and usages. Or, when flow control is never needed, a subscriber may initially request an effectively unbounded number of items, as in:" />
      <item value="The default value of defaultBufferSize may provide a useful starting point for choosing request sizes and capacities in Flow components based on expected rates, resources, and usages" />
      <item value="where a buffer size of 1 single-steps" />
      <item value="A Flow.Subscriber arranges that items be requested and processed. Items (invocations of Flow.Subscriber.onNext) are not issued unless requested" />
      <item value="not issued" />
      <item value="arranges" />
      <item value="that can be used to avoid resource management problems that may otherwise occur in &quot;push&quot; based systems." />
      <item value="Communication relies on a simple form of flow control (method Flow.Subscription.request) that can be used to avoid resource management problems that may otherwise occur in &quot;push&quot; based systems." />
      <item value="All (seven) methods are defined in void &quot;one-way&quot; message style." />
      <item value="correspond" />
      <item value="Publishers produce items consumed by one or more Subscribers, each managed by a Subscription." />
      <item value="Interrelated" />
      <item value="签到&#10;" />
      <item value="转盘&#10;" />
      <item value="进行&#10;" />
      <item value="进行状态&#10;" />
      <item value="process_state&#10;" />
      <item value="Shipment" />
      <item value="发货状态&#10;" />
      <item value="deliver_goods&#10;&#10;" />
      <item value="deliver_gods&#10;" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="7780" />
        <entry key="ENGLISH" value="7781" />
        <entry key="CHINESE_CLASSICAL" value="1" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="9" />
        <entry key="GERMAN" value="11" />
        <entry key="FRENCH" value="19" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="5" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="7" />
        <entry key="MALAY" value="2" />
        <entry key="NORWEGIAN" value="3" />
        <entry key="PORTUGUESE" value="9" />
        <entry key="SWEDISH" value="4" />
        <entry key="SERBIAN" value="1" />
        <entry key="SLOVAK" value="5" />
        <entry key="WELSH" value="1" />
        <entry key="SPANISH" value="13" />
        <entry key="HUNGARIAN" value="5" />
        <entry key="ITALIAN" value="6" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1665194662583" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20191101000350914" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="JetBrains Mono" />
    <option name="translator" value="BAIDU" />
  </component>
</application>